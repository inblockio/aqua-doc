"use strict";(self.webpackChunkaqua_docs_v_2=self.webpackChunkaqua_docs_v_2||[]).push([[643],{7455:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"references","title":"References","description":"Signature","source":"@site/versioned_docs/version-1.2.0/references.md","sourceDirName":".","slug":"/references","permalink":"/docs/v2/references","draft":false,"unlisted":false,"editUrl":"https://github.com/inblockio/versioned_docs/version-1.2.0/references.md","tags":[],"version":"1.2.0","frontMatter":{"title":"References"},"sidebar":"tutorialSidebar","previous":{"title":"Contribution Guidelines","permalink":"/docs/v2/contribution-guidelines"}}');var a=t(4848),s=t(8453);const r={title:"References"},o=void 0,c={},h=[{value:"Signature",id:"signature",level:2},{value:"Wallet",id:"wallet",level:2},{value:"Account",id:"account",level:3},{value:"Domain",id:"domain",level:3},{value:"Transaction Security",id:"transaction-security",level:3},{value:"Data Asset",id:"data-asset",level:3},{value:"Data Vault",id:"data-vault",level:3},{value:"Metadata",id:"metadata",level:2},{value:"Witness",id:"witness",level:2},{value:"Witness network",id:"witness-network",level:3},{value:"Encryption",id:"encryption",level:2},{value:"Hash",id:"hash",level:2},{value:"Verification Process",id:"verification-process",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"signature",children:"Signature"}),"\n",(0,a.jsxs)(n.p,{children:["A signature in AQP is a cryptographic signature generated by public-private key pair. The protocol should be abstract, where it will support \u2018Method\u2019 in later iterations. This will allow us to use different types of implementations such as: ",(0,a.jsx)(n.code,{children:"PGP signatures"}),", ",(0,a.jsx)(n.code,{children:"Ethereum"}),", or ",(0,a.jsx)(n.code,{children:"Bitcoin wallet \u2019s"})," signatures."]}),"\n",(0,a.jsx)(n.p,{children:"In this specification, we use the AQP reference implementation\u2019s signing method, which is via an Ethereum wallet."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"signature_hash = calculate_hash_sum(\n    signature + public_key\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"The signature is generated by a wallet signing the following message:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'I sign the following page verification_hash:" +[0x0x9dab72<revision_verification_hash>]\n'})}),"\n",(0,a.jsx)(n.h2,{id:"wallet",children:"Wallet"}),"\n",(0,a.jsx)(n.p,{children:"A wallet is a software for protecting and managing private cryptographic keys\n(of private-public key pairs) which are used to govern digital assets. This is\ndone by authorization of transactions via digital signatures or by initiating\ndecryption processes to access data."}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"design-principles.md#separation-of-account-and-service",children:"Separation of Concerns"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"account",children:"Account"}),"\n",(0,a.jsx)(n.p,{children:"We are following Ethereum's account definition:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["In general, there are two types of accounts. Externally owned accounts,\ncontrolled by private keys. And contract accounts, controlled by their\ncontract code\n-- ",(0,a.jsx)(n.a,{href:"https://ethereum.org/en/whitepaper/#ethereum-accounts",children:"Ethereum Whitepaper"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In general, we can't prove if an account owner is a person or a machine. With\nadvancements in AI, it will become increasingly difficult to prove that a human\nis a human. ",(0,a.jsx)(n.a,{href:"https://www.proofofhumanity.id/",children:"Attempts are being made"}),' to\nincrease trustworthiness of accounts which fall short in questions of privacy\nand security as they make public claims. Traditional know your customer (KYC)\ncombined with the AQP and Aqua Identity Protocol (AIP) identification processes\ncan provide similar "proof of being human" which can be attested to an account.\nThis allows us to outsource the problem of identification, where we only focus\non unique accounts which are sufficient for data accounting independent of\nhumans or machines. Identity claims issued via the AIP will help to provide the\ncontext required to meaningfully interact between accounts.']}),"\n",(0,a.jsxs)(n.p,{children:["For more on this topic, please read the ",(0,a.jsx)(n.a,{href:"aqua-identity-protocol.md",children:"Aqua Identity\nProtocol"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"domain",children:"Domain"}),"\n",(0,a.jsxs)(n.p,{children:["A domain is a unique namespace attributed to an account. It allows us to manage\nservices and files within that namespace creating a domain of data governance\nAfter granted permissions, additional accounts can be added to share control\nover a domain or singular assets. To enforce boundaries of a domain, additional\nsoftware like the ",(0,a.jsx)(n.a,{href:"guardian.md",children:"Guardian"})," is required."]}),"\n",(0,a.jsx)(n.p,{children:"E.g. by setting up the a data vault with your account it becomes your\ndomain of data governance."}),"\n",(0,a.jsx)(n.h3,{id:"transaction-security",children:"Transaction Security"}),"\n",(0,a.jsx)(n.p,{children:"Transaction security is an economic measure of the level of integrity assurance\nfor a transaction. It is defined as the cost required to forge a transaction.\nThe transaction security can be increased by cryptographic security and by strong\nreplication of transactions. Public distributed ledger systems are highly suitable\nfor providing very high level of transaction security at the cost of privacy\nand immutability (data can't be changed or deleted). Today, public distributed\nledgers such as Bitcoin and Ethereum provide the highest level of transaction\nsecurity."}),"\n",(0,a.jsx)(n.h3,{id:"data-asset",children:"Data Asset"}),"\n",(0,a.jsx)(n.p,{children:"Data turns into a valuable asset if it is accounted for. In an accounted form\nit can be easily priced, exchanged or traded."}),"\n",(0,a.jsx)(n.h3,{id:"data-vault",children:"Data Vault"}),"\n",(0,a.jsx)(n.p,{children:"Software used to store and manage data with an account. The software must apply\na secure architecture and measures for keeping data assets safe. This is\nachieved through encryption, strong authentication and restrictive access to\nkeep data private by default."}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"design-principles.md#separation-of-account-and-service",children:"Design Principles / Separation of Account and\nService"})]}),"\n",(0,a.jsx)(n.h2,{id:"metadata",children:"Metadata"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"metadata_hash = calculate_hash_sum(\n    domain_id + time_stamp + previous_verification_hash\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Description:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"metadata_hash: The check sum for all metadata data fields. It simplifies the\nhash construction and the ability to identify data corrupton in this part of\nthe verification structure."}),"\n",(0,a.jsx)(n.li,{children:"domain_id: 10 digits hexadecimal randomly generated to identify the host\nsystem that runs the AQP service."}),"\n",(0,a.jsx)(n.li,{children:"time_stamp: time-stamp of the current revision (decimal numbers\nYYYYMMDDHHMMSS e.g. 20211128092608)."}),"\n",(0,a.jsx)(n.li,{children:"previous_verification_hash: previous_revision_verification_hash if present"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"witness",children:"Witness"}),"\n",(0,a.jsx)(n.p,{children:"Witnessing allows one to undeniably prove the existence of a dataset\n(represented as a portable hash chain). To complete the witnessing process, a\nDomain Snapshot is created. This is a collection of all revision hashes within\none domain. A Merkle tree is used to unify all hashes of the latest revisions\nof all portable hash chains within a domain into a single hash value."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"witness_event_verification_hash"})," is written to the ",(0,a.jsx)(n.a,{href:"#witness-network",children:"Witness\nNetwork"}),". The\n",(0,a.jsx)(n.code,{children:"witness_event_verification_hash"})," is then generated by using the\n",(0,a.jsx)(n.code,{children:"domain_snapshot_genesis_hash"})," and the ",(0,a.jsx)(n.code,{children:"merkle_root"})," hash together. This\nallows the page snapshot itself to also be witnessed."]}),"\n",(0,a.jsx)(n.p,{children:"A single revision which has been witnessed, will not store the whole Merkle\ntree, but only its relevant path to the Merkle root. Performing a Merkle proof\nmeans that its revision is included in the Merkle tree."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"witness_hash = calculate_hash_sum(\n    domain_snapshot_genesis_hash + merkle_root +\n    witness_network + witness_event_transaction_hash\n)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"witness-network",children:"Witness network"}),"\n",(0,a.jsx)(n.p,{children:"We are using the Ethereum Network as an optional Witness Network for\ncryptographic time-stamping."}),"\n",(0,a.jsx)(n.h2,{id:"encryption",children:"Encryption"}),"\n",(0,a.jsx)(n.p,{children:"according to wikipedia"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"In cryptography, encryption (more specifically, encoding) is the process of transforming information in a way that, ideally, only authorized parties can decode. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Despite its goal, encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor.\n\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hash",children:"Hash"}),"\n",(0,a.jsx)(n.p,{children:"according to investopedia"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'A hash is a mathematical function that converts an input of arbitrary length into an encrypted output of a fixed length. Thus, regardless of the original amount of data or file size involved, its unique hash will always be the same size. Moreover, secure hashes cannot be "reverse-engineered" to get the input from the hashed output, at least with current technology.\n\nIf you use a specific function on the same data, its hash will be identical, so you can validate that the data is the same (i.e., unaltered) if you already know its hash. A different function would deliver a different hash.\n\n'})}),"\n",(0,a.jsx)(n.h3,{id:"verification-process",children:"Verification Process"}),"\n",(0,a.jsx)(n.p,{children:"The verification process is a redo of the verification data generation\nprocess, and additionally a comparison of their results."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Verification of Content"})}),"\n",(0,a.jsx)(n.p,{children:"All hashes are recalculated in a separate client implementation, and\ncompared with the ones sent via the API. If the data was not altered or\ncorrupted; nor was there a difference in the process to calculate the\nhash, they will match. This will create a high level of assurance that\nthe integrity and history of the portable hash chain in question has not been\naltered."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Verification of Account"})}),"\n",(0,a.jsx)(n.p,{children:"We cryptographically verify that the revision signature is indeed generated by the account specified in the verification data."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Verification of Time"})}),"\n",(0,a.jsxs)(n.p,{children:["To verify that the witness event included in a revision is correct, a\nlookup and comparison of the ",(0,a.jsx)(n.code,{children:"witness_event_verification_hash"})," on-chain is\nperformed and compared with the recalculated event."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);